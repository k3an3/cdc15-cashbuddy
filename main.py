from flask import Flask, request, abort, render_template

from utils import *
from models import *


app = Flask(__name__)

@app.route("/", methods=['GET'])
def index():
    return render_template('index.html', **locals())

@app.route("/begin_transaction", methods=['POST'])
def begin_transaction():
    txid = request.form.get('txid')
    postback = request.form.get('postback')
    amount = num(request.form.get('amount'))
    if txid and postback and amount:
        pass
    abort(401)

@app.route("/validate_transaction", methods=['GET'])
def validate_transaction():
    try:
        txid = Transaction.get(txid=request.form.get('txid'))
    except TransactionDoesNotExist:
        return 'FALSE'
    return 'TRUE' if txid.paid else 'FALSE'

@app.route("/login", methods=['GET', 'POST'])
def login():
	if request.method == 'POST':
		try:
			user = User.get(email=request.form.get('email'))
			password = request.form.get('password')
			if user and user.password == get_password(password):
				session = Session(user=user, session_id=generate_session_id())
				session.save()
				response = make_response(redirect('/account'))
				response.set_cookie('session_id', session.session_id)
				return response
		except User.DoesNotExist:
			pass
		error = "The email and password you entered do not match."
	return render_template('login.html', **locals())

@app.route("/register")
def register():
	pass

@app.route("/account")
def account():
	pass


# This hook ensures that a connection is opened to handle any queries
# generated by the request.
@app.before_request
def _db_connect():
    db.connect()

# This hook ensures that the connection is closed when we've finished
# processing the request.
@app.teardown_request
def _db_close(exc):
    if not db.is_closed():
        db.close()


if __name__ == "__main__":
    app.debug = True
    db_init()
    app.run(host='0.0.0.0')
